# -*- coding: utf-8 -*-
"""Stock Prediction Using RNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dAsXgSQA2Kq03wRzciJE4eGkigGHrD-I
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pandas_datareader import data as pdr
import yfinance as yf

yf.pdr_override()
y_symbols = ['ZEEL.NS']
from datetime import datetime
startdate = datetime(2007,1,1)
enddate = datetime(2019,12,31)
data = pdr.get_data_yahoo(y_symbols, start=startdate, end=enddate)

data

data=data.reset_index()
data.head()

data_training = pd.DataFrame(data['Close'][0:int(len(data)*0.70)])
data_testing = pd.DataFrame(data['Close'][int(len(data)*0.70): int(len(data))])
print(data_training.shape)
print(data_testing.shape)

data_training

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0,1))
data_training_array = scaler.fit_transform(data_training)
data_training_array

x_train = []
y_train = []

for i in range(100, data_training_array.shape[0]):
    x_train.append(data_training_array[i-100:i])
    y_train.append(data_training_array[i,0])

x_train,y_train = np.array(x_train), np.array(y_train)

x_train.shape

past_100_days = data_training.tail(100)

print(type(past_100_days))

final_df = pd.concat([past_100_days, data_testing], ignore_index=True)

final_df.head()

input_data = scaler.fit_transform(final_df)
input_data

input_data.shape

x_test = []
y_test = []

for i in range(100,input_data.shape[0]):
   x_test.append(input_data[i-100:i])
   y_test.append(input_data[i,0])

x_test,y_test = np.array(x_test), np.array(y_test)
print(x_test.shape)
print(y_test.shape)

from keras.models import Sequential
from keras.layers import SimpleRNN, Dense

# Define the model architecture
model = Sequential()
model.add(SimpleRNN(units=32, input_shape=(None, 1)))
model.add(Dense(units=1, activation='sigmoid'))
# Compile the model
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
# Train the model
model.fit(x_train, y_train, epochs=10, batch_size=32)
# Evaluate the model
loss, accuracy = model.evaluate(x_test, y_test)

y_predicted = model.predict(x_test)

y_predicted.shape

y_test

y_predicted

scaler.scale_

scale_factor = 1/0.00262985
y_predicted = y_predicted * scale_factor
y_test = y_test * scale_factor

plt.figure(figsize=(8,3))
plt.plot(y_test, '#580F41', label = 'Original Price')
plt.plot(y_predicted, '#E50000', label = 'Predicted Price')
plt.xlabel('Days')
plt.ylabel('Price')
plt.legend()
plt.show()

test = pd.DataFrame(y_test)
test.rename(columns={0: 'Test_value'}, inplace=True)
test

predicted = pd.DataFrame(y_predicted)
predicted.rename(columns={0: 'Predicted_value'}, inplace=True)
predicted

from sklearn.metrics import r2_score
r_squared = r2_score(test, predicted)
print("R-squared:", r_squared)

import pandas as pd
from sklearn.metrics import accuracy_score, f1_score, roc_auc_score

# Assuming you have loaded your data into pandas DataFrame
# Replace df_test with the actual name of your DataFrame containing Test_value and Predicted_value
# Replace threshold_value with the appropriate threshold for your binary classification problem


threshold_value = 0.2  # Adjust this threshold according to your problem

# Convert probabilities to binary predictions based on the threshold
true_labels_binary = (test > threshold_value).astype(int)
predictions_binary = (predicted > threshold_value).astype(int)

# Calculate F1-score
f1 = f1_score(true_labels_binary, predictions_binary)

# Calculate accuracy
accuracy = accuracy_score(true_labels_binary, predictions_binary)

roc_auc = roc_auc_score(true_labels_binary, predictions_binary)


print(f"F1-score: {f1}")
print(f"Accuracy: {accuracy}")
print(f"ROCAUC: {roc_auc}")

from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

# Calculate Mean Squared Error (MSE)
mse = mean_squared_error(test, predicted)

# Calculate Mean Absolute Error (MAE)
mae = mean_absolute_error(test, predicted)

# Calculate R-squared (R^2) score
r2 = r2_score(test, predicted)

print("Mean Squared Error:", mse)
print("Mean Absolute Error:", mae)
print("R-squared (R^2) Score:", r2)